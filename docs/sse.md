# Server-Sent Events (SSE)

**Server-Sent Events (SSE)** — это технология HTML5, позволяющая серверу в реальном времени отправлять обновления и сообщения на веб-клиент (браузер) по одному долговременному HTTP-соединению, без необходимости постоянных запросов со стороны клиента, работая в одностороннем порядке (от сервера к клиенту).

## Как это работает

1. **Клиентский запрос**: Браузер устанавливает HTTP-соединение с сервером.
2. **Ответ сервера:** Сервер отвечает с заголовком `Content-Type: text/event-stream`, указывая, что это поток событий.
3. **Поток данных:** Сервер отправляет данные в виде текстовых сообщений (событий), разделенных новой строкой, по этому же соединению.
4. **Клиентская обработка:** JavaScript-интерфейс `EventSource` на клиенте слушает и обрабатывает эти события по мере их поступления.

## Ключевые особенности

- **Однонаправленность:** Только от сервера к клиенту.
- **Простота:** Легче в настройке, чем WebSockets, использует обычный HTTP.
- **Автоматическое переподключение:** Встроенная поддержка восстановления связи при обрыве.

**Примеры использования:** Ленты новостей, обновления статусов, спортивные результаты, потоковая передача данных от LLM.

## Разница с WebSockets

- **SSE:** Проще, однонаправленный, поверх HTTP, для "push-уведомлений" с сервера, например, новостей.
- **WebSockets:** Двунаправленный, более сложный, для полной интерактивной связи, например, чатов, игр.

## Server-Sent Events (SSE) в Чистой архитектуре

```yaml
[ Usecase ]
    |
    | Publish(event)
    v
[ Domain Event ]
    |
    v
[ In-Memory SSE Broker ]  <── HTTP clients
        |
        └── fan-out → connections
```

❗ Usecase не знает про SSE
❗ SSE знает про события

## Формат SSE событий

Сервер пишет ТЕКСТ:

```bash
event: user.created
id: 123
data: {"id": "123", "email": "a@b.com"}
```

Обязательное:

- пустая строка = конец события
- `data`: можно несколько строк
- `\n\n` — граница

## HTTP-заголовки

- **Content-Type:** `text/event-stream`
- **Cache-Control:** `no-cache, no-store, must-revalidate` - отключает кеширование, поскольку поток данных постоянно обновляется и клиенту всегда нужна самая актуальная информация
- **Connection:** `keep-alive`

---

```go
type EventBroker interface {
    Subscribe(ctx context.Context, clientID string) chan []byte
    Unsubscribe(ctx context.Context, clientID string)
}
```
